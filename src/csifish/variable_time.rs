use crate::csifish::lattice::ReducedClassGroupElement;
use crate::csifish::montgomery::{MontgomeryCurve, Point};
use crate::csifish::field_arithmetic::base_field::FieldElement;
use crate::csifish::field_arithmetic::arithmetic::{ModularArithmetic, MontgomeryArithmetic};
use crate::csifish::constants::{LADDER, NUM_PRIMES, PRIMES16, P_GMP};
use rug::integer::Order::LsfLe;
use rug::Integer;

pub trait VariableTimeCurve {
    fn on_curve(&self, p: &Point) -> bool;
    // fn variable_time_differential_addition_chain(&self, p: &Point, primes: &[usize]) -> Point;
    fn variable_time_differential_addition_chain(&self, p: &Point, primes: &u128) -> Point;
    fn variable_time_isogeny(&self, k: &Point, ell: usize, p1: &Point) -> (Point, MontgomeryCurve);
}

impl VariableTimeCurve for MontgomeryCurve {
    // Whether p corresponds to any rational point on the curve
    #[inline(always)]
    fn on_curve(&self, p: &Point) -> bool {
        let sq = p.x.square();
        let x3 = sq * p.x; // cube of p.x
        let x2 = sq * self.a.x;
        let rhs = x3 + x2 + p.x;
        // If rhs is square, point is only rational on this curve
        // If rhs is zero, point is rational on both curve and twist
        // If rhs is non-square, point is only rational on the twist

        // for the given prime, legendre of the montgomery form is equivalent to
        // legendre of the number itself
        let l = Integer::from_digits(&rhs.get_montgomery().map(|x| x.to_le()), LsfLe)
            .legendre(&P_GMP);
        // let l = jacobi_vartime(&rhs);
        l == 1
    }

    // computes x([4 * k]P), for a subset  primes \subseteq [3, 5, 7, ..., 587]
    // primes contains the indices of the primes needed.
    // See: https://eprint.iacr.org/2017/293.pdf
    #[inline(always)]
    fn variable_time_differential_addition_chain(&self, p: &Point, prime_mask: &u128) -> Point {
        let mut p = p.clone();
        for j in 0..NUM_PRIMES {
            if (prime_mask >> j) & 1 == 0 {
                continue;
            }
            let p2 = self.double(&p);
            let p3 = self.differential_add(&p2, &p, &p);
            let mut r = [p, p2, p3];
            for chain in &LADDER[j] {
                let rc1 = r[chain ^ 1];
                let rc = r[*chain];
                let r2 = r[2];
                if !rc.is_zero() {
                    r = [rc1, r2, self.differential_add(&r2, &rc1, &rc)];
                } else {
                    r = [rc1, r2, self.double(&r2)];
                }
            }
            p = r[2];
        }
        p
    }

    // Computes isogeny phi with kernel generated by point k, with order ell
    // Returns codomain curve of isogeny and image of point p under the isogeny
    fn variable_time_isogeny(&self, k: &Point, ell: usize, p1: &Point) -> (Point, MontgomeryCurve) {
        //compute twisted Edwards curve coefficients
        let mut edwards_z = self.a.z + self.a.z;
        let mut edwards_x = self.a.x + edwards_z;
        edwards_z = self.a.x - edwards_z;

        let padd: FieldElement = p1.x + p1.z;
        let psub: FieldElement = p1.x - p1.z;

        let mut prod = Point {
            x: k.x - k.z,
            z: k.x + k.z,
        };

        let tmp1 = prod.x * padd;
        let tmp0 = prod.z * psub;
        let mut q = Point {
            x: tmp0 + tmp1,
            z: tmp0 - tmp1,
        };
        // precompute a24.x = A.x+2*A.z, a24.z = 4*A.z
        let t = self.a.z + self.a.z;
        let a24 = Point {
            x: self.a.x + t,
            z: t + t,
        };

        let p2 = Point {
            x: (k.x + k.z).square(),
            z: (k.x - k.z).square(),
        };
        let c = p2.x - p2.z;
        let b = a24.z * p2.z;
        let a = (c * a24.x) + b;
        let mut cyclic_kernel = [
            k.clone(),
            Point {
                x: p2.x * b,
                z: a * c,
            },
            Point::zero(),
        ];

        for i in 1..(ell / 2) {
            let cur = cyclic_kernel[i % 3];
            let mut tmp1 = cur.x - cur.z;
            let mut tmp0 = cur.x + cur.z;
            prod.x *= tmp1;
            prod.z *= tmp0;
            tmp1 *= padd;
            tmp0 *= psub;
            q.x *= tmp0 + tmp1;
            q.z *= tmp0 - tmp1;
            cyclic_kernel[(i + 1) % 3] =
                self.differential_add(&cur, k, &cyclic_kernel[(i - 1) % 3]);
        }
        q.x = q.x.square() * p1.x;
        q.z = q.z.square() * p1.z;

        edwards_x = edwards_x.vartime_exp(&(ell as u64));
        edwards_z = edwards_z.vartime_exp(&(ell as u64));
        edwards_x *= prod.z.square().square().square();
        edwards_z *= prod.x.square().square().square();
        let mut ax = edwards_x + edwards_z;
        ax += ax;
        let az = edwards_x - edwards_z;
        let codomain = MontgomeryCurve::projective(ax, az);
        (q, codomain)
    }
}

pub trait VariableTimeAction {
    fn variable_time_action(&self, e: &MontgomeryCurve) -> MontgomeryCurve;
}

impl VariableTimeAction for ReducedClassGroupElement {
    fn variable_time_action(&self, e: &MontgomeryCurve) -> MontgomeryCurve {
        let mut e = e.clone();
        let mut exponents = self.exponents.clone();
        assert_eq!(e.a.z, FieldElement::ONE);
        let mut done: [bool; 2] = [false, false];
        let mut prime_mask = [0u128, 0u128];
        for j in 0..NUM_PRIMES {
            if exponents[j] > 0 {
                prime_mask[0] |= 1u128 << j;
            } else if exponents[j] < 0 {
                prime_mask[1] |= 1u128 << j;
            }
        }

        while !done[0] || !done[1] {
            let p = Point::random();
            //any x-coord is on a curve or its twist
            let sign: usize = 1 - e.on_curve(&p) as usize;
            if done[sign] {
                continue;
            }
            // q = [(p+1)/k]p
            //double twice for cofactor
            let mut q = e.variable_time_differential_addition_chain(
                &e.double(&e.double(&p)),
                &(!prime_mask[sign]),
            );
            for prime_idx in (0..NUM_PRIMES).rev() {
                if (prime_mask[sign] >> prime_idx) & 1 != 0 {
                    prime_mask[sign] &= !(1u128 << prime_idx);
                    // k = [k/ell]q = [(p+1)/ell]p
                    let k = e.variable_time_differential_addition_chain(&q, &prime_mask[sign]);
                    // need kernel to have order ell, skip if not
                    if !k.is_zero() {
                        // compute isogeny corresponding to action of one ideal
                        (q, e) = e.variable_time_isogeny(&k, PRIMES16[prime_idx] as usize, &q);
                        // reduce exponent for that ideal, if it is zero we add it to kernel order
                        exponents[prime_idx] = exponents[prime_idx] - 1 + 2 * sign as i8;
                    }
                }
            }
            assert_eq!(prime_mask[sign], 0);
            for j in 0..NUM_PRIMES {
                prime_mask[sign] |= (((exponents[j] * (1i8 - (sign << 1) as i8)) > 0) as u128) << j;
                // if (exponents[j] * (1i8 - (sign << 1) as i8)) > 0 {
                //     prime_mask[sign] |= (((exponents[j] * (1i8 - (sign << 1) as i8)) > 0) as u128) << j;
                // }
            }
            done[sign] = prime_mask[sign] == 0;
            //for the on-curve function to work
            e = e.normalize();
        }
        e
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn isogeny() {
        let a = FieldElement::ZERO;
        let b = FieldElement::from_be_hex("53BAA451F759835A01933C76BC58C0C203A9B6B02F7F086B30C3469A8452750AAECA8A4F7C26BFF43876F4510F405F4D2A006635D89A42D327D9A2E8C00BF340");
        let order: usize = 3;

        let k = Point::from_x(FieldElement::from_be_hex("22B668C942BF7D5F5DF869A215F7E9463A0A873CFE2953721F129EC98B8123A8E62DF0D1F100AA92F4C6C8552AD62C42C11DB1AE8540F46ADC16D8939808553A"));
        let p = Point::from_x(FieldElement::from_be_hex("0A3A72458C434F22FD1F2B441C3BAD38C0C069872F69372A43E818126CFF49DC3CA63E87BC5F0443201F9DA03EFE8DA618C4D207954D40F774A923CBC11F2CA7"));
        let im_p = Point::from_x(FieldElement::from_be_hex("1ED168610F98DC95AAB55E2B067E92B32AF0A436A73EF7142F31BC3CBE2A532F8D51061DA110C5EB01FEC1838C6D0AA3B643D90181AAA3184CF02ABB20ECFB2A"));

        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.variable_time_isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = FieldElement::from_be_hex("48211766D23E629D22C38ED44B3D8A02622B7022E5CE2CE5CCF7CDD4F901213AE61B00371E74AD24C9F71C59C0B0269287B36EC9652F4ACC421B8975C8C9EE4F");
        let b = FieldElement::from_be_hex("20B68C844B20BBA2271497C8ECD471D2EB0E3640A3D238F142C13C3C86BDF9D2F758186586740B2A15F9709E18F93F7894704B23CCBB533AC8AD2F1031AE309B");
        let order: usize = 5;
        let k = Point::from_x(FieldElement::from_be_hex("409548FAF7B5117391A5AD4D1202CA9EE096D69F44188441796F2ACED23C0C21DA29C9286AD5A46636CE1E41F9F54CEF4F453F7EFFCD595E168CC519DD68EA51"));
        let p = Point::from_x(FieldElement::from_be_hex("3B2DC0FD5EE8C65F43DAD597D8C48C32138A9FE4A1008802D5CED33523731EB432469E2D7F2276625E3DF38566576180E559E1C13D5F9565696A6D0D83830FF4"));
        let im_p = Point::from_x(FieldElement::from_be_hex("3BF01DE995EB675B0C2303367BC0FC3F82AC3D7123F842DEC8DE1E34F6FE14FBFDC1BDF203914BF7F6C52A7AF66CA745D4C682A4D1C9F40D1D5CFB066BB46B2D"));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.variable_time_isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = FieldElement::from_be_hex("48912381B13014DF7E10F242424DFE6D43860ED48A2913843A45E75E15615849B2E2C8191E6CEF70A931E20883E8B59B87046926B8E534DCA88722A8E204496C");
        let b = FieldElement::from_be_hex("4E7D723C463A2F779721CD1F53CB1F2F3F9ECEB60E1831A2DDC665687C1F7BD1B479670592F4967DFAD3F9675B6229ED2B4ECFC2AAE33258DAF6A1B5CCBF2B78");
        let order: usize = 173;
        let k = Point::from_x(FieldElement::from_be_hex("54C8CDA4F5B40B4DD5EF9011AFA313195A68106114B157B53270CB1005C8338E4CE00C826ECEE406027F383FA1D5037DBB81D92E4203B4092B9C3D20A32D49A8"));
        let p = Point::from_x(FieldElement::from_be_hex("55E59A6BB770F1477F38E747D4C45F61CDA4D068736398DCB7C3A6B872208E6BA55FA42377A4B3EB25AEF4D0CE59C91A1D3A291B87700FFFE21805A7DEED199B"));
        let im_p = Point::from_x(FieldElement::from_be_hex("5BBC4E76109DAF1BCC7A597C78DCA56C1645CA6C72859B3F316F972054BF200C0F8059E2CCD9B1886F7518230CC5A75E210A3A5C07D843FF79BD832B675E1BD3"));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.variable_time_isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = FieldElement::from_be_hex("4F80CF43DC32028D21AF9A4596C7067352C764156B62056D1DBC2A528E367DAC0BC65E453F01864DF53E0A775E064988EDD71034EBE1D5B95C1235F11DC6ACFD");
        let b = FieldElement::from_be_hex("1AFAA394A786BAEB11895EE8A455AE6A6872C74C9D2F0F47773AAB2FD1481BACC7695E7B81177C643C054D3BD36268F5ABD7AE225EEBEFA531F9153F532E4BA5");
        let order: usize = 83;
        let k = Point::from_x(FieldElement::from_be_hex("425A0D7407BF49078B071367E138506CDF3CF5C5231384524F9C62C7E84BF1536C47B5AC7B981BD1D8B8A4FF5ED0A75471F0D80ED1515CE18C2D31780929FD58"));
        let p = Point::from_x(FieldElement::from_be_hex("1C33BAADF7E34ACA1AFE98CEF02BA3948B0A09A2996BC9BC2C28A4E33A4943E8FA63370DF59C0CDA3C1D943473E50B2D4334DEE8263F6CF6450619460BF09DC4"));
        let im_p = Point::from_x(FieldElement::from_be_hex("46C02021FCC07A06A4C41958C3C40EB31DF7D10947C1021FE2638A9DADB7C8792D8EC0271FE63DFDE0BF6E1B4D44E550A9606DC91541DC15263292469892BD8D"));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.variable_time_isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = FieldElement::from_be_hex("38C29C0734D6DD3278A7DCDB797A4D8D1E6C41ADAC0FA768EE3BF9EE8FBC3EECE077F09DE1644631226B822B3BA01868DE4A9E7603DADA2D024BB5B16E083020");
        let b = FieldElement::from_be_hex("2FDC10B37A9570DFA25AEE9482802ECDC60E7D5D47B6E06AC5C3114BA70DDF38C6D820DFAD5A126794DC0CCF78A3BB91283DEAE9D6B540EB45506934D5C145B7");
        let order: usize = 149;
        let k = Point::from_x(FieldElement::from_be_hex("5E9D1A6638D9610AE0568BC36A483E512E3AC582C45E79A5388D0C213F7315052B4B74784F468E9D5CE9EA882D9511AF4A7B92E7CDEC4D5AE22D32D8B9F805DE"));
        let p = Point::from_x(FieldElement::from_be_hex("35EE2441FB15C6C330837FA2950A9860C33A14E6847D78DE6EB62FF85291477CEB7E69CE825B88637283A87379AC17D3A1E319A2D95172CFFC31FE6380C54749"));
        let im_p = Point::from_x(FieldElement::from_be_hex("3A12C8F02C85892393291F5860DB7B8C86C198FE89B44B165A91E9C05F185896C036B64331A418347706C6D124B73AECE248925112F207E3E53114FEECE14545"));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.variable_time_isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);
    }

    #[test]
    fn variable_time_action() {
        let e = MontgomeryCurve::new(FieldElement::ZERO);
        let exp: [i8; NUM_PRIMES] = [
            -5, 2, 0, -3, 4, -4, -5, 3, 5, -1, -2, -4, 0, -2, -3, 3, 1, -2, 5, 3, 4, 3, -4, 2, 2,
            3, -1, 0, 1, -3, 0, 1, -5, -2, 0, 2, 0, 0, -5, 5, 4, 5, 0, -5, 0, -1, 0, 1, 5, 1, 1,
            -3, 0, 5, 1, 2, -1, 1, -5, 0, 1, 5, 3, 2, -1, -5, 4, 2, 1, 2, -2, 0, 1, 5,
        ];

        let g1 = ReducedClassGroupElement::new(exp);
        let b = g1.variable_time_action(&e);

        let correct1 = FieldElement::from_be_hex("2D3F42F31F984ACE1F45E62D35F7C9936BA51863A204A7AF9562DF7822E01323EAECAB2D86BBA42CB9B1DAA7DAA565800BD5BF35A0297218E8CBDB0399618180");

        assert_eq!(b.normalize().a.x, correct1);

        let exp: [i8; NUM_PRIMES] = [
            1, -2, 5, 1, 2, 4, -1, 0, -2, -1, 2, 5, -3, 3, 3, -1, -2, -1, 0, -5, -1, -1, -5, 4, 2,
            -1, -1, -5, -4, -3, 4, 1, 4, -2, 4, -5, 3, -1, 1, 2, 0, 4, 1, -5, 4, 1, 4, -1, 0, -5,
            3, -2, -3, 0, -1, 4, 3, -2, -5, -5, 4, 3, 2, 1, -2, 3, 3, -2, -3, -5, 5, 3, -5, 2,
        ];

        let g2 = ReducedClassGroupElement::new(exp);
        let b = g2.variable_time_action(&e);

        let correct2 = FieldElement::from_be_hex("09EB001955B4E84ECFFE86806E0C8313800D0475CFF3519FAF30DC5F3A060E97AE258051DABED0245406DF3BD41B4A03F3C7756C2DE8DE4AD28AC8CD8D506695");

        assert_eq!(b.normalize().a.x, correct2);

        let e1 = MontgomeryCurve::new(correct1);
        let c = g2.variable_time_action(&e1);

        let correct3 = FieldElement::from_be_hex("2BA3EBCD76B29349F525D3B73BA841065926870C3A1F23902EF53652D880BCF6E8D2705B2F94E23551BBFE9F4FD9A4DA1EADF24EA62DC2A7F425A8EB901E31A6");

        assert_eq!(c.normalize().a.x, correct3);

        let e2 = MontgomeryCurve::new(correct2);
        let c = g1.variable_time_action(&e2);
        assert_eq!(c.normalize().a.x, correct3);

        let a = FieldElement::from_be_hex("5EB2AEEF49060ED93CC067CC83EDDA45D2494F1CF0EB19F41DA034D00A61CBFDFE7C05C0E2730E14EE51B1C0DD5F10CD4958FB9567E9125410860FADDE6D5306");
        let e3 = MontgomeryCurve::new(a);
        let exp: [i8; NUM_PRIMES] = [
            -5, 2, -5, -1, -4, -3, 5, 4, -2, 5, 3, -4, 4, 4, 5, 5, -5, -1, -2, -1, 2, -3, 1, -5,
            -2, 5, 5, 5, -2, 2, 3, 4, 2, -5, 4, 2, 1, 4, -3, 1, -3, 0, 5, 4, -4, 0, 0, -3, 1, 3, 0,
            -1, -4, -4, -5, -4, -5, 3, -3, 0, -4, 2, -1, 4, 5, 0, -3, 3, -4, -1, -2, -2, 2, -5,
        ];

        let g = ReducedClassGroupElement::new(exp);
        let b = g.variable_time_action(&e3);

        let correct = FieldElement::from_be_hex("244BFECEC58AB059E806D5E001BFA1230F5FD3735C2D78EA8F901E4C3FDE881D2FBE39781C948436C538EFA0E2C54B650E390D2B519BD6A3BA6026AFCC819DCB");
        assert_eq!(correct, b.normalize().a.x);

        let b = g.variable_time_action(&e);
        let correct = FieldElement::from_be_hex("0313B6847C6679D3E73A9DD53E2C48E7E1279BE4749D519B2CC13FF5F7D8B235944A1994761C0DFD8306A899567D1DE98ECE0F2431C907EAC61CD5E1F34E0E9E");
        assert_eq!(correct, b.normalize().a.x);
    }

    #[test]
    fn t() {
        let e = MontgomeryCurve::new(FieldElement::ZERO);
        let exp: [i8; NUM_PRIMES] = [
            -5, 2, 0, -3, 4, -4, -5, 3, 5, -1, -2, -4, 0, -2, -3, 3, 1, -2, 5, 3, 4, 3, -4, 2, 2,
            3, -1, 0, 1, -3, 0, 1, -5, -2, 0, 2, 0, 0, -5, 5, 4, 5, 0, -5, 0, -1, 0, 1, 5, 1, 1,
            -3, 0, 5, 1, 2, -1, 1, -5, 0, 1, 5, 3, 2, -1, -5, 4, 2, 1, 2, -2, 0, 1, 5,
        ];

        let g1 = ReducedClassGroupElement::new(exp);
        let b = g1.variable_time_action(&e);
        let correct1 = FieldElement::from_be_hex("2D3F42F31F984ACE1F45E62D35F7C9936BA51863A204A7AF9562DF7822E01323EAECAB2D86BBA42CB9B1DAA7DAA565800BD5BF35A0297218E8CBDB0399618180");

        assert_eq!(b.normalize().a.x, correct1);
    }
}
